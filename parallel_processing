1.  并发与并行
并发：交替处理多个任务的能力，不一定同时，程序在同一个CPU上。
并行：同时处理多个任务的能力。
 
2.	多进程可充分利用CPU多个内核进行处理，而多线程无法实现并行。原因在于Python中存在GIL（全局解释器锁），其作用就是保证同一个时刻只有一个线程可执行代码。
3.	阻塞和非阻塞（针对于进程在访问数据的时候而言的），同步和异步（应用程序和内核的交互而言的）
1)	阻塞：读取和写入函数将一直的等待；
2)	非阻塞：读取和写入函数立即返回一个状态值；
    阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪;
3)	同步：用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪；
4)	异步：用户进程触发IO操作以后便开始做自己的事情（IO完成之后会得到通知）；
    同步和异步是指访问数据的机制,同步一般指主动请求并等待I/O操作完毕的方式,当数据就绪后在读写的时候必须阻塞(区别就绪与读写二个阶段,同步的读写必须阻塞),
    异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。(等待"通知")
5)	其实阻塞与非阻塞都可以理解为同步范畴下才有的概念，对于异步，就不会再去分阻塞非阻塞。对于用户进程，接到异步通知后，就直接操作进程用户态空间里的数据好了。同步和异步是相对于应用和内核的交互方式而言的，同步需要主动去询问，而异步的时候内核在IO事件发生的时候通知应用程序，而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。

4.	I/O模型分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO；
1）	同步阻塞IO：只有当IO操作完成后，进程才能运行（传统的JAVA IO模型）；
2）	同步非阻塞IO：发起IO操作后，可返回做其他事情，但是需要询问IO是否准备就绪，从而导致CPU资源浪费（目前的JAVA的NIO）；
3）	异步阻塞IO：异步可以在IO操作完成后会自动通知程序，至于阻塞是因为调用的select函数，该函数本身是阻塞的；
4）	异步非阻塞IO：此模式下，用户进程只需要发起一个IO操作然后立即返回，等IO完成后会得到通知，此时进程只需要对数据进行处理即可（目前JAVA没有这种模型）
5）	同步阻塞和同步非阻塞
①	同步阻塞，进程烧水，就不能煮粥
②	同步非阻塞，类似于一个进程完成上述两个操作，好处在于一个进程处理多个i/o请求，劣势在于需要不停的轮询
③	两者区别就在于是否等待数据就绪
④	同步非阻塞I/O的调用不会等待数据的就绪，若是数据不可读或者不可写会立即返回通知进程

5.	进程和线程
进程：一段程序的执行过程（有三个转态：就绪—获得了除CPU外的所有资源、阻塞—I/O阻塞和运行—正在运行程序）具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位
线程：独立运行的程序片段。多线程是为了同步完成多项任务，提高资源的有效利用率。线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，
     由线程ID、程序计数器、寄存器集合和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。线程没有自己的系统资源。

假如有两个程序A和B，程序A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。
你是不是已经想到在程序A读取数据的过程中，让程序B去执行，当程序A读取完数据之后，让程序B暂停。这里涉及到了：切换。

进程的切换：想象一位有一手好厨艺的计算机科学家正在为他的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料:面粉、鸡蛋、糖、香草汁等。在这个比喻中，
做蛋糕的食谱就是程序(即用适当形式描述的算法)计算机科学家就是处理器(cpu)，而做蛋糕的各种原料就是输入数据。进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。
现在假设计算机科学家的儿子哭着跑了进来，说他的头被一只蜜蜂蛰了。计算机科学家就记录下他照着食谱做到哪儿了(保存进程的当前状态)，然后拿出一本急救手册，按照其中的指示处理蛰伤。
这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(实施医疗救治)，每个进程拥有各自的程序(食谱和急救手册)。当蜜蜂蛰伤处理完之后，这位计算机科学家又回来做蛋糕，
从他离开时的那一步继续做下去.

线程的出现是为了降低上下文切换的消耗提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能。
线程的使用：假设，一个文本程序，需要接受键盘输入，将内容显示在屏幕上，还需要保存信息到硬盘中。若只有一个进程，势必造成同一时间只能干一样事的尴尬（当保存时，就不能通过键盘输入内容）。
若有多个进程，每个进程负责一个任务，进程A负责接收键盘输入的任务，进程B负责将内容显示在屏幕上的任务，进程C负责保存内容到硬盘中的任务。这里进程A，B，C间的协作涉及到了进程通信问题，
而且有共同都需要拥有的东西——-文本内容，不停的切换造成性能上的损失。若有一种机制，可以使任务A，B，C共享资源，这样上下文切换所需要保存和恢复的内容就少了，同时又可以减少通信所带来的性能损耗，
那就好了。是的，这种机制就是线程。


例子：CPU代表一个工厂，一个工厂会包括许多车间，而这些车间就代表一个进程，任一时刻，CPU总是运行一个进程，其他进程都处于非运行状态。在车间中，有许多工人，这些工人代表线程即一个进程包括多个线程，
多个线程可以合作完成某一个任务。一个进程的内存空间是共享的，每个线程都可以使用这些共享内存，但是在某线程占据某一块内存时，其它线程需要等待其完成结束才可使用。防止多个线程同时读取某一块内存区域的方法是加互斥锁。
操作系统的设计，因此可以归结为三点：
1)	以多进程形式，允许多个任务同时运行；
2)	以多线程形式，允许单个任务分成不同的部分运行；
3)	提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源
4)	一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
5)	资源分配给进程，同一进程的所有线程共享该进程的所有资源；
6)	CPU分给线程，即真正在CPU上运行的是线程
进程例：CPU读取A程序上下文，CPU执行，CPU保存上下文
线程例：CPU在读取A程序上下文时，分为三个片段a,b,c来读取，这里a,b,c就是线程，他们共享了A程序上下文的环境是更为细小的CPU时间段。

6.	对于计算来说，cpu越多好，对于I/O操作来说，cpu的数量与其关系不大。

7.	解决Python中GIL的方法：利用multiprocessing 来代替Thread multiprocessing，开启了多进程后每个进程之间的GIL互不干扰。但是其引入会导致数据通讯和同步中的困难增加。比如，多线程之间是共享同一个进程资源的，
在进行例如累加任务时只需要声明一个全局变量GLOBAL即可，但是由于不同进程之间无法实现资源共享，因此只能在主线程申明QUEUE。

8.	python下想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。
9.	对于计算密集型任务，常使用多进程来进行实现，I/O任务较少，因此建立进程个数较少，计算时间占用更多，需要更多的CPU进行计算；对于I/O密集型任务，由于I/O任务较多，创建进程时花费的时间比创建线程花费的时间更长，因此常使用多线程。
